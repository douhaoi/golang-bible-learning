# 第12章　反射

Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。

在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的API是如何使用反射机制的：一个是fmt包提供的字符串格式化功能，另一个是类似encoding/json和encoding/xml提供的针对特定协议的编解码功能。对于我们在4.6节中看到过的text/template和html/template包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。

## TypeScript 对照
- 运行时类型：Go 可用 `reflect.Type/Value` 获取并操作类型信息；TS 编译后类型被擦除，只能依赖运行时数据或装饰器元数据。
- 空接口 vs any：`interface{}` 传递任意类型，需配合反射区分具体类型；TS 中 `any`/`unknown` 常用类型守卫。
- 可寻址性：只有可寻址的 `reflect.Value` 才能修改原值，类似 TS 中需要持有可变引用。
- 标签：结构体字段 tag（如 `json:"name" validate:"required"`）可通过反射读取；TS 需自定义装饰器或 schema 库（zod/io-ts）。

### 示例：使用反射读取字段标签
```go
package main

import (
	"fmt"
	"reflect"
)

type User struct {
	Name string `json:"name" validate:"required"`
	Age  int    `json:"age"`
}

func main() {
	t := reflect.TypeOf(User{})
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		fmt.Println(f.Name, f.Tag.Get("json"), f.Tag.Get("validate"))
	}
}
```

```ts
// TS 没有内置结构体标签，可用装饰器模拟（需开启 experimentalDecorators）
function Json(name: string) {
  return Reflect.metadata("json", name);
}

@Reflect.metadata("validate", "required")
class User {
  @Json("name")
  name!: string;
  @Json("age")
  age!: number;
}

// 读取元数据
console.log(Reflect.getMetadata("json", User.prototype, "name")); // "name"
```

### 踩坑提醒
- 反射操作失败多在运行时暴露（panic），需检查 `IsValid`、`CanSet` 等状态。
- 频繁使用反射会影响性能和可读性，优先考虑显式类型或泛型。
- 与 `interface{}` 组合时，类型断言失败要处理布尔返回，避免 panic。
