# 第11章　测试

Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过分悲观的想法，虽然也许会有人困惑于他对软件开发的难度的天真看法。

现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。

我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。

软件测试是一个巨大的领域。测试的任务可能已经占据了一些程序员的部分时间和另一些程序员的全部时间。和软件测试技术相关的图书或博客文章有成千上万之多。对于每一种主流的编程语言，都会有一打的用于测试的软件包，同时也有大量的测试相关的理论，而且每种都吸引了大量技术先驱和追随者。这些都足以说服那些想要编写有效测试的程序员重新学习一套全新的技能。

Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。

在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。

## TypeScript 对照
- 约定优于配置：`go test` 自动发现 `*_test.go` 中 `func TestXxx(t *testing.T)`；TS 常用 Jest/Vitest，需配置 runner。
- 表驱动测试：用切片存用例并循环，类似 TS 参数化测试。
- 基准测试：`func BenchmarkXxx(b *testing.B)` 原生支持性能跑分；TS 需借助 `benchmark.js` 或 `vitest` benchmark 扩展。
- 覆盖率：`go test -cover` 对应 TS 的 `c8` 或 `nyc`。
- 示例函数：`func ExampleXxx()` 可生成文档并验证输出，TS 需自建示例测试。

### 示例：表驱动测试对照
```go
// calc.go
package calc

func Add(a, b int) int { return a + b }
```

```go
// calc_test.go
package calc

import "testing"

func TestAdd(t *testing.T) {
	cases := []struct {
		a, b int
		want int
	}{
		{1, 2, 3},
		{-1, 1, 0},
	}
	for _, c := range cases {
		if got := Add(c.a, c.b); got != c.want {
			t.Fatalf("Add(%d,%d)=%d want %d", c.a, c.b, got, c.want)
		}
	}
}
```

```ts
// calc.ts
export const add = (a: number, b: number) => a + b;
```

```ts
// calc.test.ts (Vitest)
import { describe, it, expect } from "vitest";
import { add } from "./calc";

describe("add", () => {
  const cases = [
    { a: 1, b: 2, want: 3 },
    { a: -1, b: 1, want: 0 },
  ];
  cases.forEach((c) => {
    it(`${c.a}+${c.b}=${c.want}`, () => {
      expect(add(c.a, c.b)).toBe(c.want);
    });
  });
});
```

### 踩坑提醒
- 测试文件需后缀 `_test.go`，包名可与被测包一致或使用包名加后缀 `_test` 做黑盒测试。
- `go test` 会为每个包单独构建临时模块，依赖 `go.mod` 完整性；修改环境变量时注意隔离。
- 基准测试默认运行时间较短，可用 `-bench`、`-benchmem`、`-benchtime` 调整，避免误读数据。
