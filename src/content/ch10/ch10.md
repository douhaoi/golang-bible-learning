# 第10章　包和工具

现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。

Go语言有超过100个的标准包（译注：可以用`go list std | wc -l`命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 http://godoc.org 检索。在本章，我们将演示如何使用已有的包和创建新的包。

Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。

## TypeScript 对照
- 模块导入：Go `import "example.com/pkg/util"` 基于模块路径解析，类似 TS `import { x } from "pkg/util"` 但无相对/绝对混搭的路径别名。
- 包命名：包名通常与目录名一致；`import alias "path/pkg"` 类似 TS 导入别名。
- 工具链：`go build/test/vet/fmt` 对应 TS 的 `tsc`, `npm test`, `eslint`, `prettier`；`go` 工具原生集成，无额外脚本。
- 匿名导入：`import _ "pkg/logger"` 仅执行初始化副作用，类似 TS 的 `import "./setup"`。
- 依赖管理：`go mod tidy` 拉取缺失依赖、修剪多余依赖，类似 `npm install` + `npm prune`。

### 示例：包与导入别名
```go
// main.go
package main

import (
	util "example.com/project/internal/util"
	"fmt"
)

func main() {
	fmt.Println(util.Add(1, 2))
}
```

```go
// internal/util/util.go
package util

func Add(a, b int) int { return a + b }
```

```ts
// main.ts
import { add } from "./util";

console.log(add(1, 2));
```

```ts
// util.ts
export function add(a: number, b: number) {
  return a + b;
}
```

### 踩坑提醒
- 包名与导入路径可不同，但导入时使用路径，引用时用包名（或别名）；不允许循环依赖。
- 未使用的导入/标识符无法通过编译；与 TS/ESLint 的可配置警告不同。
- `go install`/`go run` 会基于当前模块解析依赖，确保 `go.mod` 在仓库根部并保持整洁（`go mod tidy`）。 
