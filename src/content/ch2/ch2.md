# 第2章　程序结构

Go语言和其他编程语言一样，一个大的程序是由很多小的基础构件组成的。变量保存值，简单的加法和减法运算被组合成较复杂的表达式。基础类型被聚合为数组或结构体等更复杂的数据结构。然后使用if和for之类的控制语句来组织和控制表达式的执行流程。然后多个语句被组织到一个个函数中，以便代码的隔离和复用。函数以源文件和包的方式被组织。

我们已经在前面章节的例子中看到了很多例子。在本章中，我们将深入讨论Go程序基础结构方面的一些细节。每个示例程序都是刻意写的简单，这样我们可以减少复杂的算法或数据结构等不相关的问题带来的干扰，从而可以专注于Go语言本身的学习。

## TypeScript 对照
- 类型声明：Go 需显式类型或让编译器推断；TS 亦可推断，但 Go 的类型不可被重新打开扩展。
- 变量声明：`:=` 同时声明+推断，类似 `const/let`；Go 没有 `var` 提升，作用域以块为单位。
- 自定义类型：`type Celsius float64` 是新底层类型（不可与 `float64` 混用），TS 的 `type`/`interface` 多为别名/结构约束。
- 包导出：标识符首字母大写即导出，类似 TS 的 `export`；包名通常与目录名一致。
- 作用域：Go 块级作用域与 TS 类似，但没有函数提升；短变量声明会“遮蔽”外层同名变量。

### 示例：类型与短变量声明
```go
package main

import "fmt"

type UserID int

func main() {
	id := UserID(42) // 推断为 UserID
	msg := fmt.Sprintf("user %d", id)
	fmt.Println(msg)
}
```

```ts
type UserID = number;

const id: UserID = 42;
const msg = `user ${id}`;
console.log(msg);
```

### 踩坑提醒
- Go 自定义类型与底层类型不自动互转，需要显式转换；TS 别名可直接互用。
- 未使用的变量/导入在 Go 会编译失败，写样例时务必用到。
- 短变量声明 `:=` 会重用已存在的变量时需谨慎，避免无意覆盖。
